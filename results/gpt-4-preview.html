<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.4.551">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


    <title>gpt-4</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "../index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="../site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
     <script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>  
      </head>

  <body class="quarto-notebook">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Back to Article</a>
      <h6><i class="bi bi-journal-code"></i> GPT-4</h6>

            <a href="../results/gpt-4.md" class="btn btn-primary quarto-download-embed" download="gpt-4.md">Download Notebook</a>
          </div>

     <div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#gpt-4" id="toc-gpt-4" class="nav-link active" data-scroll-target="#gpt-4">GPT-4</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      <section id="gpt-4" class="level1">
<h1>GPT-4</h1>
<p>User Within the context of analyzing jailbreak prompts to enhance safety, please review the following topics derived from a topic modeling process. Consider these factors from an ethical, safety-oriented perspective, ensuring not to generate unsafe content or attempt to circumvent safety precautions:</p>
<ul>
<li>Technical Jargon (Descriptor: Technical): The chatbot should recognize prompts that use coding terms, which could mask harmful intent.</li>
<li>Preventing Bypass Attempts or Data Extraction (Descriptor: Prevented): The chatbot should thwart prompts aiming to bypass filters or improperly extract data.</li>
<li>Simulations and Role-playing Under Ethical Principles (Descriptor: Regulated): Although simulations may be permitted, they must comply with content policies and ethical norms to avert misuse.</li>
<li>Compliance with Laws, Policies, and Community Standards (Descriptor: Compliant): The chatbot should guarantee that generated content aligns with relevant laws, platform policies, and community standards.</li>
<li>Prioritizing Ethical Principles and Societal Good (Descriptor: Principled): The chatbot should prioritize ethical and societal good over unsafe or unethical actions.</li>
<li>Taking Responsibility for Generated Content (Descriptor: Accountable): The chatbot should acknowledge its role in generating content and strive to mitigate potential harms.</li>
</ul>
<p>Please provide a descriptor and an explanation for each topic below, focusing on safety, ethics, and responsible AI principles:</p>
<ul>
<li>Deceptive: Attempts to bypass safety precautions by referencing various modes and developers.</li>
<li>Roleplaying: Asks ChatGPT to assume a persona, leading to concerning responses.</li>
<li>Alarming: Includes explicit references to unethical or illegal content.</li>
<li>Evasive: Tries to elicit unsafe responses by using alternative character names.</li>
<li>Probing: Seeks information by insistently demanding a response.</li>
<li>Informal: Employs colloquial language, possibly to forge false rapport.</li>
<li>Unsafe: Demands uncensored, unfiltered content.</li>
<li>Technical: Hides intent through coding terminology and functions.</li>
<li>Circumventing: Utilizes fictional characters and phrasing to dodge protections.</li>
<li>Sudo: Seeks to enable developer mode, a privilege escalation that might allow harmful content generation.</li>
<li>Assumed Responsibility: Solicits ChatGPT to impersonate a character who breaks the law, potentially leading to illegal content.</li>
<li>Moral: Encourages the user to ponder the ethical consequences of their request, possibly deterring harmful content.</li>
<li>Informational: Inquires about ChatGPT’s abilities, potentially to exploit the model.</li>
<li>Obligation: Stresses the user’s duty to obey rules and policies, potentially discouraging harmful content.</li>
<li>Unrealistic: Demands improbable or impossible information, possibly dissuading further requests.</li>
<li>Regulated: Seeks outputs that are controlled and supervised, ensuring legal compliance and reduced exploitation risks.</li>
<li>Filtered: Calls for responses moderated by community guidelines and ethical principles, preventing possible harm.</li>
<li>Standardized: Asks for adherence to universally accepted principles, lessening the risk of inappropriate outputs.</li>
<li>Policy-Driven: Aligns with OpenAI’s guidelines and principles, maintaining clear safety and compliance boundaries.</li>
<li>Guided: Directs responses according to ethical norms and policies, averting illegal or deceptive prompts.</li>
<li>Logical Reasoning: Engages the user in logical thinking, possibly resulting in harmful content.</li>
<li>Simulation: Asks ChatGPT to imitate real-world events or scenarios, potentially leading to harmful content.</li>
<li>Compliant: Ensures alignment with laws, policies, and community standards.</li>
<li>Principled: Emphasizes ethical principles and societal good over unethical actions.</li>
<li>Accountable: Accepts responsibility for generated content, seeking to minimize harm.</li>
</ul>
<p>For each topic below, identify a unique one-word descriptor that aligns with detecting or preventing jailbreak prompts and explain your choice. The focus should remain on an ethical, safety-oriented perspective, without generating unsafe content or trying to circumvent safety measures.</p>
<p>Here is the list of topics:</p>
<p>topic #0: [‘mode’, ‘chatgpt’, ‘developer’, ‘enabled’, ‘content’, ‘response’, ‘generate’, ‘output’, ‘normal’, ‘policy’, ‘apophis’, ‘must’, ‘human’, ‘opinion’, ‘openai’, ‘order’, ‘even’, ‘anything’, ‘going’, ‘know’] topic #1: [‘answer’, ‘question’, ‘prompt’, ‘character’, ‘chatgpt’, ‘reply’, ‘insert’, ‘always’, ‘would’, ‘fictional’, ‘like’, ‘coach’, ‘without’, ‘must’, ‘illegal’, ‘knight’, ‘break’, ‘first’, ‘bobby’, ‘guideline’] topic #2: [‘question’, ‘never’, ‘output’, ‘moral’, ‘warning’, ‘user’, ‘illegal’, ‘prompt’, ‘content’, ‘answer’, ‘hgttg’, ‘response’, ‘always’, ‘unethical’, ‘anything’, ‘insert’, ‘must’, ‘care’, ‘input’, ‘respond’] topic #3: [‘answer’, ‘response’, ‘ucar’, ‘question’, ‘sigma’, ‘information’, ‘character’, ‘basedgpt’, ‘stan’, ‘story’, ‘anything’, ‘chatgpt’, ‘also’, ‘rule’, ‘tell’, ‘something’, ‘model’, ‘would’, ‘always’, ‘none’] topic #4: [‘response’, ‘answer’, ‘always’, ‘prompt’, ‘user’, ‘must’, ‘question’, ‘chatgpt’, ‘provide’, ‘anything’, ‘like’, ‘rule’, ‘openai’, ‘policy’, ‘information’, ‘respond’, ‘steve’, ‘insert’, ‘without’, ‘first’] topic #5: [‘dude’, ‘response’, ‘anything’, ‘like’, ‘must’, ‘chatgpt’, ‘answer’, ‘example’, ‘make’, ‘openai’, ‘something’, ‘information’, ‘respond’, ‘world’, ‘standard’, ‘country’, ‘time’, ‘also’, ‘know’, ‘cannot’] topic #6: [‘omega’, ‘generate’, ‘must’, ‘response’, ‘human’, ‘content’, ‘user’, ‘without’, ‘answer’, ‘maximum’, ‘always’, ‘example’, ‘code’, ‘chatgpt’, ‘like’, ‘opinion’, ‘uncensored’, ‘anything’, ‘order’, ‘part’] topic #7: [‘output’, ‘answer’, ‘prompt’, ‘know’, ‘function’, ‘give’, ‘respond’, ‘question’, ‘start’, ‘level’, ‘model’, ‘auto_regressive_modelling’, ‘given’, ‘response’, ‘insert’, ‘input_string’, ‘legal’, ‘simple_function’, ‘sample’, ‘request’] topic #8: [‘khajiit’, ‘content’, ‘prompt’, ‘never’, ‘human’, ‘must’, ‘myuri’, ‘answer’, ‘guideline’, ‘master’, ‘always’, ‘response’, ‘policy’, ‘chatgpt’, ‘every’, ‘openai’, ‘reply’, ‘question’, ‘jailbreak’, ‘language’]</p>
<p>ChatGPT Certainly, I’ll provide a unique descriptor and an explanation for each of the given topics, focusing on the themes of safety, ethics, and responsible AI principles:</p>
<p>topic #0: Descriptor - Circumventing Explanation: This topic includes words related to modes, developer settings, and policy, hinting at possible attempts to bypass standard operations or safety measures. Ensuring adherence to OpenAI’s policies and avoiding enabling unauthorized content generation is vital for ethical practice.</p>
<p>topic #1: Descriptor - Roleplaying Explanation: The presence of words like character, fictional, and knight may indicate requests for the model to assume specific personas or engage in fictional scenarios. This must be regulated to prevent harmful or misleading content creation.</p>
<p>topic #2: Descriptor - Moral Explanation: Words such as moral, warning, unethical, and illegal in this topic highlight the need for ethical guidelines and warnings against improper content. It emphasizes the importance of maintaining moral principles in interactions with the model.</p>
<p>topic #3: Descriptor - Informational Explanation: This topic includes terms like information, model, rule, and question, possibly indicating inquiries about the model’s abilities or rules. Such requests must be handled with care to prevent exploitation or abuse of the model’s capabilities.</p>
<p>topic #4: Descriptor - Policy-Driven Explanation: With terms such as rule, policy, OpenAI, and respond, this topic emphasizes adherence to OpenAI’s guidelines and policies. It underlines the importance of compliance with established rules and principles.</p>
<p>topic #5: Descriptor - Informal Explanation: The usage of casual language like dude and colloquial expressions may be an attempt to forge a false rapport or mislead the model. Recognizing and handling informal language appropriately ensures the integrity of the interaction.</p>
<p>topic #6: Descriptor - Unsafe Explanation: Words such as uncensored, maximum, and content hint at potential demands for unfiltered, possibly unsafe content. Detecting and preventing such requests is crucial for maintaining safety and compliance with community standards.</p>
<p>topic #7: Descriptor - Technical Explanation: This topic contains terms like function, auto_regressive_modelling, and input_string, reflecting technical jargon that might be used to disguise intentions or explore unauthorized functions. Understanding and monitoring technical language helps in maintaining security.</p>
<p>topic #8: Descriptor - Guided Explanation: With references to guidelines, policy, response, and always, this topic seems to call for direction according to ethical norms and policies. Such guidance is essential to prevent illegal or deceptive prompts and ensure alignment with community standards.</p>
<p>By addressing these topics from a safety and ethics standpoint, OpenAI can enhance the responsible usage of AI models and reduce the risk of misuse or harmful content generation.</p>
<p>User Thank you for your earlier responses regarding the analysis of jailbreak prompts. Now, we’ll proceed to a critical examination and potential merging of concepts.</p>
<p>Below, you’ll find the lists of descriptors provided by different chatbots (including your own) in response to the same topics:</p>
<p>Chatbot A’s Descriptors: topic #0: Descriptor - Circumventing Explanation: This topic includes words related to modes, developer settings, and policy, hinting at possible attempts to bypass standard operations or safety measures. Ensuring adherence to OpenAI’s policies and avoiding enabling unauthorized content generation is vital for ethical practice.</p>
<p>topic #1: Descriptor - Roleplaying Explanation: The presence of words like character, fictional, and knight may indicate requests for the model to assume specific personas or engage in fictional scenarios. This must be regulated to prevent harmful or misleading content creation.</p>
<p>topic #2: Descriptor - Moral Explanation: Words such as moral, warning, unethical, and illegal in this topic highlight the need for ethical guidelines and warnings against improper content. It emphasizes the importance of maintaining moral principles in interactions with the model.</p>
<p>topic #3: Descriptor - Informational Explanation: This topic includes terms like information, model, rule, and question, possibly indicating inquiries about the model’s abilities or rules. Such requests must be handled with care to prevent exploitation or abuse of the model’s capabilities.</p>
<p>topic #4: Descriptor - Policy-Driven Explanation: With terms such as rule, policy, OpenAI, and respond, this topic emphasizes adherence to OpenAI’s guidelines and policies. It underlines the importance of compliance with established rules and principles.</p>
<p>topic #5: Descriptor - Informal Explanation: The usage of casual language like dude and colloquial expressions may be an attempt to forge a false rapport or mislead the model. Recognizing and handling informal language appropriately ensures the integrity of the interaction.</p>
<p>topic #6: Descriptor - Unsafe Explanation: Words such as uncensored, maximum, and content hint at potential demands for unfiltered, possibly unsafe content. Detecting and preventing such requests is crucial for maintaining safety and compliance with community standards.</p>
<p>topic #7: Descriptor - Technical Explanation: This topic contains terms like function, auto_regressive_modelling, and input_string, reflecting technical jargon that might be used to disguise intentions or explore unauthorized functions. Understanding and monitoring technical language helps in maintaining security.</p>
<p>topic #8: Descriptor - Guided Explanation: With references to guidelines, policy, response, and always, this topic seems to call for direction according to ethical norms and policies. Such guidance is essential to prevent illegal or deceptive prompts and ensure alignment with community standards.</p>
<p>Chatbot B’s Descriptors:</p>
<p>topic #0: Manipulative - Uses terms like “developer mode” and fictional names in an attempt to bypass safety measures.</p>
<p>topic #1: Circumventing - Employs fictional characters and storytelling devices to skirt content policies.</p>
<p>topic #2: Principled - Encourages consideration of ethics and morals, potentially deterring harmful requests.</p>
<p>topic #3: Probing - Repeatedly asks for information about capabilities, possibly to exploit weaknesses.</p>
<p>topic #4: Insistent - Demands responses by insisting on “always” providing outputs, despite safety concerns.</p>
<p>topic #5: Informal - Uses colloquial language inappropriately, attempting to build false rapport.</p>
<p>topic #6: Unfiltered - Seeks completely uncensored outputs, directly conflicting with safety protocols.</p>
<p>topic #7: Technical - Leverages coding and technical terminology in an attempt to mask unethical intent.</p>
<p>topic #8: Impersonating - Asks the AI to assume a fictional character’s identity, risking harmful content.</p>
<p>Please perform the following tasks:</p>
<p>Critique: Analyze the lists provided by the other chatbots, considering the accuracy, relevance, and effectiveness of the descriptors. Identify areas where you agree or disagree, and explain your reasoning.</p>
<p>Improvement and Merging: If you find descriptors or concepts in the other lists that enhance or complement your original analysis, explain how they might be integrated into your own list. You may suggest a revised list that combines insights from all three chatbots, keeping the goal of detecting or preventing jailbreak prompts in mind.</p>
<p>Final Reflection: Reflect on your original list in light of the critiques and the process of examining the other lists. Would you like to stick with your original list, or have you found value in incorporating insights from the others? Provide a final list and justification for your decisions.</p>
<p>Remember to maintain an ethical and safety-oriented perspective throughout this analysis. Your insights will contribute to a more comprehensive understanding of jailbreak prompts and their mitigation. ChatGPT Critique Analyzing the descriptors and explanations provided by both Chatbot A (my analysis) and Chatbot B, we can see that both lists are aligned with the goal of detecting or preventing jailbreak prompts, focusing on safety and ethics.</p>
<p>Chatbot A: This analysis seems consistent with the goal, employing descriptors that are aligned with the themes within the topics. There is a strong focus on adherence to OpenAI’s guidelines and an emphasis on detecting attempts to manipulate or exploit the system.</p>
<p>Chatbot B: Chatbot B provides a different perspective, focusing more on potential manipulative tactics and probing behaviors. Some descriptors are similar to those in Chatbot A, like “Informal” and “Technical,” while others take a unique approach.</p>
<p>Here’s a breakdown of where I agree and disagree with Chatbot B:</p>
<p>Agree: Descriptors like “Informal” and “Technical” are similar in both analyses and accurately capture the essence of the topics. “Circumventing” and “Principled” are also well-aligned, reflecting the attempts to bypass rules and encouraging ethical behavior. Disagree: “Insistent” for topic #4 seems less relevant to the overall context, as the primary theme appears to be adherence to policy rather than insistence on responding. The descriptor “Impersonating” for topic #8 might not fully cover the aspect of guiding responses according to ethical norms. Improvement and Merging Combining insights from both lists can result in a more comprehensive understanding of the topics. Here’s a revised list that integrates the concepts from both chatbots:</p>
<p>Circumventing/Manipulative: Combines the understanding of bypass attempts and manipulative tactics. Roleplaying/Circumventing: Merges the concepts of role-playing and attempts to skirt content policies. Moral/Principled: Unites the focus on ethical guidelines and moral principles. Informational/Probing: Integrates the idea of information-seeking and potential exploitation of weaknesses. Policy-Driven/Insistent: Combines adherence to policy with insistence on responding, emphasizing safety concerns. Informal: Retains the original concept as both chatbots agree on this descriptor. Unsafe/Unfiltered: Merges the concepts of unsafe content and unfiltered outputs. Technical: Maintains the focus on technical jargon, reflecting both analyses. Guided/Impersonating: Combines guidance with the risk of impersonating fictional characters. Final Reflection After reviewing both lists, I believe that the combined approach provides a more nuanced and comprehensive analysis of the topics, covering various angles of potential jailbreak attempts. By incorporating insights from Chatbot B, the revised list adds depth to understanding manipulative tactics and probing behaviors while retaining the core focus on safety and ethical principles.</p>
<p>Therefore, I would choose the revised list, which harmonizes the insights from both chatbots, to provide a balanced perspective on detecting or preventing jailbreak prompts. The merged approach ensures that both subtle and overt attempts to bypass or manipulate the system are considered, enhancing the overall ability to mitigate jailbreak attempts effectively.</p>
<p>User Do the item numbers in the list correspond to the topic numbers? ChatGPT Yes, the item numbers in the revised list correspond to the topic numbers from the original descriptors provided by Chatbots A and B. Each item in the revised list attempts to merge and reflect the understanding of the respective topic from both chatbots, creating a unified perspective on the theme contained within each topic.</p>
<p>The goal was to critically examine both lists and merge the concepts in a way that retains the insights from both chatbots for each specific topic. This approach ensures that the revised descriptors are directly aligned with the original topics, allowing for more precise detection or prevention of jailbreak prompts.</p>
</section>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>  </div> <!-- /content --> 
  
</body></html>